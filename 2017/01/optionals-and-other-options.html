<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>write once, read many</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/css/theme.css" rel="stylesheet" type="text/css">
    <link href="/css/syntax.css" rel="stylesheet" type="text/css">
    <link href="/css/highlight.css" rel="stylesheet" type="text/css">


</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">write once, read many</a>
              </div>
              <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li class="active"><a href="/">Home</a></li>
                    <li class="active visible-xs-block"><a href="/links.html">Links</a></li>
                    <li class="active"><a href="/archive.html">Archive</a></li>
                    <li class="active"><a href="/about.html">About</a></li>
                    <li class="active"><a href="/feed.xml">RSS</a></li>
                    
                      <li class="active"><a href="https://github.com/writeoncereadmany">Github</a></li>
                    
                </ul>
              </div>
        </div>
    </div>
</div>


<div class="container container-left">
    <div class="row">
        <div class="col-md-3 hidden-xs">
            <div class="sidebar well">
ruminations on software development
</div>

<div class="sidebar well">
    <h1>Recent Posts</h1>
    <ul>
        
          <li><a href="/2017/09/doing-stuff-in-minima">Doing stuff in Minima</a></li>
        
          <li><a href="/2017/09/c-how-minimal-is-minima">How Minimal is Minima?</a></li>
        
          <li><a href="/2017/09/b-overloading-in-minima">Syntactic Overloading in Minima</a></li>
        
          <li><a href="/2017/09/a-minima">Minima</a></li>
        
          <li><a href="/2017/08/reflections-on-equality">Reflections on Equality</a></li>
        
    </ul>
</div>

<!--<div class="sidebar well">
<h1>Links</h1>
<ul>
  <li><a href="#">One</a></li>
  <li><a href="#">Two</a></li>
  <li><a href="#">Three</a></li>
  <li><a href="#">Four</a></li>
</ul>

</div>-->

        </div>
        <div class="col-md-9">
          <div class="article">
            <div class="well">
                <h1><a href="/2017/01/optionals-and-other-options">Jan 22, 2017 - Optionals, and other options</a></h1>
            
            <div class="post-content">
            <p>So I was recently talking about how much better than <code class="highlighter-rouge">null</code> <code class="highlighter-rouge">Optional</code> is, and the importance of using it correctly in order to get the most out of what they offer over <code class="highlighter-rouge">null</code>.</p>

<p>What I didn’t talk about, though, was why you’d use either in the first place. Turns out that when you look at that, with a critical eye, <code class="highlighter-rouge">Optional</code> doesn’t <em>entirely</em> solve the problem we have.</p>

<p>Let’s take the example of the King of Spain’s beard.</p>

<p><!--more--></p>

<h3 id="the-king-of-spains-beard">The King of Spain’s Beard</h3>

<p><img src="http://study.com/cimages/multimages/16/philip_ii_of_spain_by_antonio_moro.jpg" alt="King Phillip 2 of Spain" /></p>

<p>What’s the colour of the King of Spain’s beard? From the image above, I’d describe it as… brown? Let’s take a look at what some code to do that might look like:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">King</span> <span class="n">king</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">();</span>
    <span class="n">Beard</span> <span class="n">beard</span> <span class="o">=</span> <span class="n">king</span><span class="o">.</span><span class="na">getBeard</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">color</span> <span class="o">=</span> <span class="n">beard</span><span class="o">.</span><span class="na">getColor</span><span class="o">();</span> 
    <span class="k">return</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Simple enough. Yeah, we could inline some stuff here, but I’m leaving types for clarity here.</p>

<p>We run this method on our test data, and we do indeed get back <code class="highlighter-rouge">"Brown"</code>. So we deploy to production, and we’re getting null pointer exceptions. What’s going on here?</p>

<p>Turns out, Phillip 2 isn’t the King of Spain anymore. This is the King of Spain:</p>

<p><img src="https://s-media-cache-ak0.pinimg.com/564x/7d/45/40/7d4540ab8158cad10c70d396ed41572b.jpg" alt="King Felipe VI of Spain" /></p>

<p>The problem here, in case it wasn’t already obvious, is the King of Spain has no beard. Therefore, asking what colour his beard is doesn’t make sense.</p>

<p>Originally when we developed our API around kings and beards, that’s not something we gave much thought to, and in the instance where a <code class="highlighter-rouge">King</code> has no <code class="highlighter-rouge">Beard</code>, we returned <code class="highlighter-rouge">null</code>, more by accident than design. That’s easy to do in a language where the entire SDK has been built around <code class="highlighter-rouge">null</code> as a signifier of an absence of a sensible answer for the best part of 20 years.</p>

<p>So now we acknowledge it’s possible for a king to <em>not</em> have a beard, we modify our API so <code class="highlighter-rouge">getBeard()</code> returns an <code class="highlighter-rouge">Optional&lt;Beard&gt;</code> for the color instead of a <code class="highlighter-rouge">Beard</code>, and our code looks like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">King</span> <span class="n">king</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">();</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Beard</span><span class="o">&gt;</span> <span class="n">beard</span> <span class="o">=</span> <span class="n">king</span><span class="o">.</span><span class="na">getBeard</span><span class="o">();</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">color</span> <span class="o">=</span> <span class="n">beard</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">color</span><span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>or, if you’re OK being less explicit about types:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">getBeard</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>We test this with the current King of Spain, and all looks sensible, so we deploy our change to production, and we go ever so slightly longer before we hit another <code class="highlighter-rouge">NullPointerException</code>.</p>

<p>At this point we have three thoughts, in roughly the following order:</p>
<ul>
  <li>Arsebiscuits!</li>
  <li>Why did I ever think monarch-beard-colors-as-a-service was a viable startup to join?</li>
  <li>Where exactly is this failing and with what inputs?</li>
</ul>

<p>As frustrating as it is, this is a problem you <em>do</em> need to solve, if only because you’ve got too much tied up in equity to give up now. So you look at the logs and see that someone queried for the color of the beard of the King of <em>France</em>. What’s the problem there?</p>

<h3 id="the-king-of-frances-beard">The King of France’s beard</h3>

<p>This is the King of France:</p>

<p><img src="https://ethicsalarms.files.wordpress.com/2016/02/empty-podium.jpg?w=400" alt="The current King of France" /></p>

<p>There hasn’t been a King of France since 1870. For that matter, there hasn’t been a King of England since 1952. It’s <em>entirely possible</em> for a country to not have a king.</p>

<p>Before we update our API, seeing as we’ve already had two production outages, we get a little paranoid and take a moment to think about whether it’s possible for a <code class="highlighter-rouge">Beard</code> to not have a color. We decide that it isn’t (grey and white are, after all, colors). We also decide that, seeing as beard colors are <code class="highlighter-rouge">String</code>s, a beard which is, say, brown and grey can be described simply enough with a single return value.</p>

<p>So we end up with code looking a bit more like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">King</span><span class="o">&gt;</span> <span class="n">king</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">();</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Beard</span><span class="o">&gt;</span> <span class="n">beard</span> <span class="o">=</span> <span class="n">king</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">);</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">color</span> <span class="o">=</span> <span class="n">beard</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">color</span><span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>Which you may choose to inline to something like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>And all is looking good in the world. Up to a point.</p>

<p>Up to the point, that is, when you get a new requirement in. It turns out that your customers aren’t entirely satisfied with that <code class="highlighter-rouge">"n/a"</code> they get when there isn’t a sensible answer to the question of “what’s the color of the king of X’s beard?”</p>

<p>On the face of it, that’s reasonable. You’re still curious exactly what your customer base is, let alone how you’re going to monetise it, but that’s beyond the scope of this blogpost.</p>

<p>So you start thinking about how to represent said failures. One approach suggests itself, but it’s somewhat clunky:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">King</span><span class="o">&gt;</span> <span class="n">king</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">king</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">name</span><span class="o">()</span> <span class="o">+</span> <span class="s">" does not have a king"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Beard</span><span class="o">&gt;</span> <span class="n">beard</span> <span class="o">=</span> <span class="n">king</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">beard</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">king</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">name</span><span class="o">()</span> <span class="o">+</span> <span class="s">" does not have a beard"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">color</span> <span class="o">=</span> <span class="n">beard</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">color</span><span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>Or maybe, seeing as we understand the importance of not calling <code class="highlighter-rouge">Optional::get</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="n">King</span><span class="o">&gt;</span> <span class="n">king</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">king</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">KingBeards:</span><span class="o">:</span><span class="n">getBeardColor</span><span class="o">)</span>
               <span class="o">.</span><span class="na">orElseGet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">country</span><span class="o">.</span><span class="na">name</span><span class="o">()</span> <span class="o">+</span> <span class="s">" does not have a king"</span><span class="o">);</span>
<span class="o">}</span> 

<span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getBeardColor</span><span class="o">(</span><span class="n">King</span> <span class="n">king</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">king</span>
        <span class="o">.</span><span class="na">getBeard</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">color</span><span class="o">)</span>
        <span class="o">.</span><span class="na">orElseGet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">king</span><span class="o">.</span><span class="na">name</span><span class="o">()</span> <span class="o">+</span> <span class="s">" does not have a beard"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Both ways work, but both are slightly hideous. You had a nice clean pipeline of composed operations and now you need to poke in the middle of them and check what’s going on.</p>

<p>This is where you start riding up against the big limitation of <code class="highlighter-rouge">Optional</code>. Its purpose is to communicate the possibility of failure, and ensure it’s handled. One thing that’s super nice about it is that it’s composable with other operations which return an <code class="highlighter-rouge">Optional</code>. But there’s one facet of failure it doesn’t consider.</p>

<p>When things fail, they fail for a reason. <code class="highlighter-rouge">Optional</code>s allow successes to propagate through operations, but all failures are reduced to a simple “sorry, no value for you” case.</p>

<p>Enter <code class="highlighter-rouge">Result</code>.</p>

<h3 id="result">Result!</h3>

<p>A <code class="highlighter-rouge">Result</code> is such a tiny step from <code class="highlighter-rouge">Optional</code> it’s almost embarassing.</p>

<p>An <code class="highlighter-rouge">Optional</code> is one of two things: either it’s a success, containing a value, or it’s a failure.</p>

<p>A <code class="highlighter-rouge">Result</code> is one of two things: either it’s a success, containing a value, or it’s a failure, <em>containing a value describing the failure</em>.</p>

<p>How often can things fail <em>and you care how</em>? That’s a place where you should consider using a <code class="highlighter-rouge">Result</code>.</p>

<p>So let’s compare how that code can look, using first <code class="highlighter-rouge">Optional</code>, not caring about the error-case:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"n/a"</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>And secondly using (a hypothetical implementation of) <code class="highlighter-rouge">Result</code>, reporting details about the error:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">success</span> <span class="o">-&gt;</span> <span class="n">success</span><span class="o">,</span>
                          <span class="n">failure</span> <span class="o">-&gt;</span> <span class="n">failure</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>The latter case assumes that <code class="highlighter-rouge">Country::getKing</code> and <code class="highlighter-rouge">King::getBeard</code> return a <code class="highlighter-rouge">Result&lt;King, String&gt;</code> and a <code class="highlighter-rouge">Result&lt;Beard, String&gt;</code> respectively, offering sensible descriptions when the operation fails.</p>

<h3 id="optionals-are-results">Optionals <em>are</em> Results</h3>

<p>From one perspective, an <code class="highlighter-rouge">Optional</code> is just a special case of <code class="highlighter-rouge">Result</code>, where the failure type is chosen to convey no useful information.</p>

<p>There’s one big pro on the side of <code class="highlighter-rouge">Optional</code> over <code class="highlighter-rouge">Result</code>: <code class="highlighter-rouge">Optional</code> is in the Java 8 API, whereas <code class="highlighter-rouge">Result</code> isn’t. That means it’s already there, other devs will be well-acquainted with its API, and other APIs will interface via <code class="highlighter-rouge">Optional</code>s.</p>

<p>On those points:</p>
<ul>
  <li>It’s really very simple to implement your own, or you could use <a href="https://github.com/unruly/control">this one we open-sourced</a>.</li>
  <li>The API could look exactly like the <code class="highlighter-rouge">Optional</code> API, only with some enhancements around dealing with failure-cases. In the linked example it doesn’t, because functions are better than methods.</li>
  <li>If you really need <code class="highlighter-rouge">Optional</code>s, it’s trivial to convert between <code class="highlighter-rouge">Result</code> and <code class="highlighter-rouge">Optional</code> at module boundaries.</li>
</ul>

<p>All the operations you’re used to on an <code class="highlighter-rouge">Optional</code> - you can do those on a <code class="highlighter-rouge">Result</code>, only now those can be augmented by operations which deal with failure values too. Whereas an <code class="highlighter-rouge">Optional</code> pipeline will continue operations until it hits an <code class="highlighter-rouge">empty</code> value (yielding <code class="highlighter-rouge">empty</code> at the end), a <code class="highlighter-rouge">Result</code> pipeline can continue operations until it hits a <code class="highlighter-rouge">failure</code> value (yielding <em>that</em> failure at the end). This means you can continue to think in terms of pipelines of operations.</p>

<h3 id="how-i-built-result">How I built Result</h3>

<p>Ultimately, a <code class="highlighter-rouge">Result&lt;S, F&gt;</code> is a generic type over two types: the type of a success, and the type of a failure. In terms of data structure, all you need is something which is <em>either</em> a success <em>or</em> a failure. It must be one or the other, and it can’t be both. In Haskell, this would be a one-liner:</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Result</span> <span class="n">s</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Success</span> <span class="n">s</span> <span class="o">|</span> <span class="kt">Failure</span> <span class="n">f</span>
</code></pre>
</div>

<p>In Java, it’s <em>just a tad</em> more verbose:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Result</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">either</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onSuccess</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">F</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onFailure</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Success</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">S</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Success</span><span class="o">(</span><span class="n">S</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">either</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onSuccess</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">F</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onFailure</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Success</span><span class="o">(</span><span class="n">onSuccess</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Failure</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">F</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Success</span><span class="o">(</span><span class="n">F</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">either</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onSuccess</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">F</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onFailure</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Failure</span><span class="o">(</span><span class="n">onFailure</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Unfortunately, this is basically the minimal case of an algebraic data type in Java.</p>

<p>This creates a type <code class="highlighter-rouge">Result</code> with two subtypes <code class="highlighter-rouge">Success</code> and <code class="highlighter-rouge">Failure</code>. It’s impossible to create further subtypes, so any <code class="highlighter-rouge">Result</code> is either a <code class="highlighter-rouge">Success</code> or a <code class="highlighter-rouge">Failure</code>. The only way to access the contents is via a single method <code class="highlighter-rouge">Result::either</code>, which requires the caller specify how to handle each case.</p>

<p>Not only that, but it encourages a syntactic style that’s reminiscent of pattern-matching in more functional languages, where we split down the possible cases and handle each separately.</p>

<p>For example, in Haskell, you might write <code class="highlighter-rouge">map</code> as follows:</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="n">s</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="n">s'</span> <span class="n">f</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Success</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Success</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Failure</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Failure</span> <span class="n">x</span>
</code></pre>
</div>

<p>The same function in Java:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">Success</span><span class="o">&lt;&gt;(</span><span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">)),</span> <span class="nl">Failure:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span> 
</code></pre>
</div>

<p>And, for good measure, here’s <code class="highlighter-rouge">flatMap</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="nl">Failure:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span> 
</code></pre>
</div>

<h3 id="methods-vs-functions">Methods vs Functions</h3>

<p>That <code class="highlighter-rouge">map</code> function could, instead, be written as a method on <code class="highlighter-rouge">Result</code>: that would be in line with what <code class="highlighter-rouge">Optional</code> does, and what Java developers would expect.</p>

<p>The problem with methods, though, is one of extensibility. In object-oriented programming, it’s easy to add new <em>types</em> which support a given set of operations: it’s much harder to add an operation to a given type. For example, let’s say we have some code which takes an <code class="highlighter-rouge">Optional</code> and fires an event based on its content, if it’s present:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nf">logEvents</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">maybeEvent</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">maybeEvent</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nl">LOG:</span><span class="o">:</span><span class="n">info</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>But now we want to log an <em>error</em> if we don’t get an event at all, well. There’s an <code class="highlighter-rouge">ifPresent()</code> method on <code class="highlighter-rouge">Optional</code>, but no <code class="highlighter-rouge">ifAbsent()</code>. This means we have various options, none of which are particularly inspiring:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// this approach is noisy, will lead to us repeating ourselves,</span>
<span class="c1">// and inverting conditions is difficult to read and easy to bug out</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nf">justInlineIt</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">maybeEvent</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">maybeEvent</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nl">LOG:</span><span class="o">:</span><span class="n">info</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">maybeEvent</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"No event present"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// this abstracts out the ifAbsent case, but it's inconsistent with the</span>
<span class="c1">// ifPresent call and it's not obvious the two lines are complementary</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nf">utilityFunction</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">maybeEvent</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">maybeEvent</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nl">LOG:</span><span class="o">:</span><span class="n">info</span><span class="o">);</span>
    <span class="n">ifAbsent</span><span class="o">(</span><span class="n">maybeEvent</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"No event present"</span><span class="o">));</span>
<span class="o">}</span>


<span class="c1">// this gives us a consistent set of operations on the event, but</span>
<span class="c1">// it's inconsistent with other usages of the Optional API</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nf">utilityFunction</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">maybeEvent</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ifPresent</span><span class="o">(</span><span class="n">maybeEvent</span><span class="o">,</span> <span class="nl">LOG:</span><span class="o">:</span><span class="n">info</span><span class="o">);</span>
    <span class="n">ifAbsent</span><span class="o">(</span><span class="n">maybeEvent</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"No event present"</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// and our helper functions</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">ifAbsent</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">maybe</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">maybe</span><span class="o">.</span><span class="na">isPresent</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">ifPresent</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">maybe</span><span class="o">,</span> <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">maybe</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">consumer</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>That’s why I implemented <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code> and so on as static methods (ie, functions) in terms of <code class="highlighter-rouge">Result::either</code>. Firstly because I can: <em>any possible interaction</em> with a <code class="highlighter-rouge">Result</code> can be implemented through <code class="highlighter-rouge">Result::either</code> - and secondly because <em>you can too</em>. The library provides many useful patterns but I’m not going to pretend I’ve considered every use-case, so it’s easy to augment it as per your requirements <em>and retain consistent calling conventions</em>.</p>

<p>So, where a method-based API would allow us to do the following:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">success</span> <span class="o">-&gt;</span> <span class="n">success</span><span class="o">,</span>
                          <span class="n">failure</span> <span class="o">-&gt;</span> <span class="n">failure</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>With just functions, we could write:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">map</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">(),</span> <span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">),</span> 
               <span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span>
           <span class="o">).</span><span class="na">either</span><span class="o">(</span>
               <span class="n">success</span> <span class="o">-&gt;</span> <span class="n">success</span><span class="o">,</span>
               <span class="n">failure</span> <span class="o">-&gt;</span> <span class="n">failure</span>
           <span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>But this is ugly. Order of operations isn’t so clear any more, and that’s when we paid particular attention to formatting. That the <code class="highlighter-rouge">flatMap</code> is being applied to the output of mapping getKing() to getBeard(), even though the <code class="highlighter-rouge">flatMap</code> is written before the <code class="highlighter-rouge">map</code> despite the <code class="highlighter-rouge">map</code> having to be called first…</p>

<p>It doesn’t have to be this way, though.</p>

<h3 id="the-applicable-pattern">The Applicable Pattern</h3>

<p>There’s no need for a tradeoff between versatility and readability here. We can just add another method to <code class="highlighter-rouge">Result</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Result</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">either</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onSuccess</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">F</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">onFailure</span><span class="o">);</span>

    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">then</span><span class="o">(</span><span class="n">ResultMapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="na">onResult</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// subtypes elided...</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ResultMapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">onResult</span><span class="o">(</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>I call this the Applicable Pattern. All the method <code class="highlighter-rouge">then</code> does is invert the calling convention: instead of passing an object to a function, you pass a function to an object. That does mean we need to express our functions in curried form instead:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">ResultMapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">Success</span><span class="o">&lt;&gt;(</span><span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">)),</span> <span class="nl">Failure:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span> 

<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">ResultMapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="nl">Failure:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span> 
</code></pre>
</div>

<p>This allows us to take all those functions, and compose them sequentially instead:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">))</span>
                  <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">))</span> 
                  <span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">success</span> <span class="o">-&gt;</span> <span class="n">success</span><span class="o">,</span> 
                          <span class="n">failure</span> <span class="o">-&gt;</span> <span class="n">failure</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>This is only marginally noisier than implementing it with regular methods:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getKingBeardColor</span><span class="o">(</span><span class="n">Country</span> <span class="n">country</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">country</span><span class="o">.</span><span class="na">getKing</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">King:</span><span class="o">:</span><span class="n">getBeard</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Beard:</span><span class="o">:</span><span class="n">getColor</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">success</span> <span class="o">-&gt;</span> <span class="n">success</span><span class="o">,</span>
                          <span class="n">failure</span> <span class="o">-&gt;</span> <span class="n">failure</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>There’s a little boilerplate in having to wrap our function calls in calls to <code class="highlighter-rouge">then</code>. That’s a minor cost. A larger cost is the impact on discoverability: now our auto-completion can’t tell us what we can do with a Result, beyond passing it two <code class="highlighter-rouge">Function</code>s or a <code class="highlighter-rouge">ResultMapper</code>. That’s the point, though: we don’t want to define a restricted set of operations.</p>

<p>For example, we often end up with the <code class="highlighter-rouge">Success</code> and <code class="highlighter-rouge">Failure</code> types being the same type, and we want to return whatever the current value is, be it success or failure. We’ve been calling <code class="highlighter-rouge">either</code> in our examples, but we could just as easily make that a function:</p>

<p>```java
public static String getKingBeardColor(Country country) {
    return country.getKing()
                  .then(flatMap(King::getBeard))
                  .then(map(Beard::getColor)) 
                  .then(collapse()); 
}</p>

<p>static Function&lt;Result&lt;T, T&gt;, T&gt; collapse() {
    return r -&gt; either(s -&gt; s, f -&gt; f);
}
```</p>

<p>We might want to map <code class="highlighter-rouge">Failure</code> values to new values/types, leaving <code class="highlighter-rouge">Success</code>es unchanged. We might want to convert a <code class="highlighter-rouge">Result&lt;S, F&gt;</code> to an <code class="highlighter-rouge">Optional&lt;S&gt;</code>, throwing away the failure value, to interact with some other API. We might want to invert a <code class="highlighter-rouge">Result</code>, flipping it so what was a <code class="highlighter-rouge">Success</code> is now a <code class="highlighter-rouge">Failure</code> and vice versa. And we might want to do many such operations, in sequence in a pipeline.</p>

<p>These are trivial functions to write, and now they can be integrated to extend the toolkit we have at our disposal - because we can bring tools into the toolkit from different packages.</p>

<h3 id="are-we-nearly-there-yet">Are we nearly there yet?</h3>

<p>If you’re dealing with operations which can fail, and you care how they fail, then a <code class="highlighter-rouge">Result</code> datatype is a good model for that. Operations which can fail are kind of our stock in trade.</p>

<p>This particular implementation of <code class="highlighter-rouge">Result</code> is designed to be easily composable and extensible. Common operations are provided, and more niche functionality is easily integrated after the fact.</p>

<p>There are many ways to compose and apply some simple operations on <code class="highlighter-rouge">Result</code>s to build clean approaches to common problems, such as validation, and useful techniques not available in vanilla Java, like flow typing. I’ll talk about some of the key examples in the next post.</p>

            </div>
            
            </div>
          </div>
          <div class="pagination">
              
                <a class="btn btn-default" href="/2017/02/failure-is-not-right" class="next">Newer Post</a>
              
              
                <a class="btn btn-default" href="/2016/12/smell-o-vision" class="previous">Older Post</a>
              
          </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12 footer navbar-inverse navbar-fixed-bottom">
            <p class="copyright">&copy;2017 write once, read many. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="https://github.com/scotte/jekyll-clean">Scott Emmons</a>
            under
            <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a></p>
        </div>
    </div>
</div>






</body>
</html>


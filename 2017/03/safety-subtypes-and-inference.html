<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>write once, read many</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/css/theme.css" rel="stylesheet" type="text/css">
    <link href="/css/syntax.css" rel="stylesheet" type="text/css">
    <link href="/css/highlight.css" rel="stylesheet" type="text/css">


</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">write once, read many</a>
              </div>
              <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li class="active"><a href="/">Home</a></li>
                    <li class="active visible-xs-block"><a href="/links.html">Links</a></li>
                    <li class="active"><a href="/archive.html">Archive</a></li>
                    <li class="active"><a href="/about.html">About</a></li>
                    <li class="active"><a href="/feed.xml">RSS</a></li>
                    
                      <li class="active"><a href="https://github.com/writeoncereadmany">Github</a></li>
                    
                </ul>
              </div>
        </div>
    </div>
</div>


<div class="container container-left">
    <div class="row">
        <div class="col-md-3 hidden-xs">
            <div class="sidebar well">
ruminations on software development
</div>

<div class="sidebar well">
    <h1>Recent Posts</h1>
    <ul>
        
          <li><a href="/2017/11/most-code-fails-badly">Most Code Fails Badly - The Case for Results</a></li>
        
          <li><a href="/2017/10/intermittency-and-interference">Intermittency, Interference and Isolation</a></li>
        
          <li><a href="/2017/09/c-how-minimal-is-minima">How Minimal is Minima?</a></li>
        
          <li><a href="/2017/09/b-overloading-in-minima">Syntactic Overloading in Minima</a></li>
        
          <li><a href="/2017/09/a-minima">Minima</a></li>
        
    </ul>
</div>

<!--<div class="sidebar well">
<h1>Links</h1>
<ul>
  <li><a href="#">One</a></li>
  <li><a href="#">Two</a></li>
  <li><a href="#">Three</a></li>
  <li><a href="#">Four</a></li>
</ul>

</div>-->

        </div>
        <div class="col-md-9">
          <div class="article">
            <div class="well">
                <h1><a href="/2017/03/safety-subtypes-and-inference">Mar 19, 2017 - Safety, subtypes and inference</a></h1>
            
            <div class="post-content">
            <p>Using <code class="highlighter-rouge">Result</code> to model potentially-failing-operations is safe in two ways. Firstly, it requires you to be explicit about how you’re handling failure cases. Secondly, it requires you to maintain a consistent model of what those successes and failures are, in order to <em>allow</em> sensible handling of them.</p>

<!--more-->

<p>For example, this code is perfectly fine:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">isHalfNPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">divideExactlyByTwo</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">isPrime</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">divideExactlyByTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">number</span> <span class="o">+</span> <span class="s">" is odd: cannot divide exactly by two"</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">number</span><span class="o">))</span>
        <span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">possibleDivisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">%</span> <span class="n">possibleDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span><span class="o">)</span>
            <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">number</span> <span class="o">+</span> <span class="s">" is not prime"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>But this code isn’t:</p>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Object</span> <span class="nf">isHalfNPrime</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class=blue><span class="n">divideExactlyByTwo</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span></span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class=pink><span class="k">this</span><span class="o">::</span><span class="n">listFactors</span></span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">divideExactlyByTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">number</span> <span class="o">+</span> <span class="s">" is odd: cannot divide exactly by two"</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">listFactors</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">primeFactors</span> <span class="o">=</span> <span class="n">IntStream</span>
        <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">number</span><span class="o">))</span>
        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">possibleDivisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">%</span> <span class="n">possibleDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">divisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="s">" is divisible by "</span> <span class="o">+</span> <span class="n">divisor</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">primeFactors</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">primeFactors</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>In the latter case, the blue function returns a <code class="highlighter-rouge">Result&lt;Integer, String&gt;</code>, then we <code class="highlighter-rouge">flatMap</code> over the pink function, which returns a <code class="highlighter-rouge">Result&lt;Integer, List&lt;String&gt;&gt;</code>. That means we have an inconsistent idea of what type a failure is, and therefore can’t do anything reasonable with it.</p>

<p>Let’s talk briefly about <code class="highlighter-rouge">flatMap</code> and why it can give us typing problems.</p>

<h3 id="flatmap-on-results-what-does-it-mean">FlatMap on Results: What Does It Mean?</h3>

<p>When we have a functional pipeline, that normally means we have an input type and an output type. We can put functions in the pipeline which transform types, and as long as each function’s input type matches its predecessor’s output type, we’re fine. Nonetheless, at any point in the pipeline, we know exactly what the type is.</p>

<p>When we’re dealing with <code class="highlighter-rouge">Result</code>s, though, we have two parallel pipelines: one for successes, and one for failures. Some functions can cross from one pipeline to another. <code class="highlighter-rouge">flatMap</code> is one of those.</p>

<p>What <code class="highlighter-rouge">flatMap</code> does is take a function which takes a success type and returns a <code class="highlighter-rouge">Result</code>, and applies it to successes in the pipeline. If they’re successful, it outputs a new success. This is guaranteed to be fine: any input successes can have any arbitrary output success types.</p>

<p>The same is not true for failures. At that point in the pipeline, we can take failures from further upstream, <em>or</em> we can generate new failures from the output of our function that was an input to <code class="highlighter-rouge">flatMap</code>. If the types of the pre-existing failure pipeline and the output of the <code class="highlighter-rouge">flatMap</code>‘d function don’t match, then we’ve lost type coherence.</p>

<p><code class="highlighter-rouge">flatMap</code> is not unique in this sense, it’s just the most common pipeline-crossing operation.</p>

<p>Fortunately, the compiler is our friend, and tells us when we get such type errors: even when we’re not picky about what we return, <code class="highlighter-rouge">isHalfNPrime</code> does not compile. There are various ways of fixing this: we could say we want our failure case to be a list of strings:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">isHalfNPrime</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">divideExactlyByTwo</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailures</span><span class="o">(</span><span class="nl">Collections:</span><span class="o">:</span><span class="n">singletonList</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">listFactors</span><span class="o">));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Or we could say we want our failure case to be a single string:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">isHalfNPrime</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">divideExactlyByTwo</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">listFactors</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">listFactors</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">primeFactors</span> <span class="o">=</span> <span class="n">IntStream</span>
        <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">number</span><span class="o">))</span>
        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">possibleDivisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">%</span> <span class="n">possibleDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">divisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="s">" is divisible by "</span> <span class="o">+</span> <span class="n">divisor</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">primeFactors</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">primeFactors</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>But in order to make this compile, we need to be conscious of what type we use to represent successes and failures at each point in the computation, and ensure they line up properly. This is entirely desirable, because otherwise we can’t deal with the failure cases sensibly. It’s also desirable that we catch this error at the point our types diverge: the earlier and more specifically that we can locate our errors, the better.</p>

<p>That’s all well and good in straightforward examples like this, but it’s not always quite so black and white. One case we ran into recently involved validation.</p>

<h3 id="validation">Validation</h3>

<p>Validation is a particularly common class of potentially-failing-operation, which has one defining property and a number of emergent properties. The defining property is:</p>

<p><em>Validating an object does not modify it.</em></p>

<p>I don’t just mean it doesn’t mutate the object: I mean that a successful validation returns the same input object, as opposed to building a new object and returning that.</p>

<p>This then implies it is possible to run multiple validations on the same object, possibly in parallel, and collapse them down into a single validation. Either all succeed, in which case we return a success of our input object, or they don’t.</p>

<p>If they don’t all succeed, what do we want our failure type to be? One answer might be “the list of errors”. That’s certainly better than arbitrarily choosing one of the errors, such as the first, but we frequently want more than that.</p>

<p>When we’re validating user input, we want to be able to return feedback to our user that helps them fix whatever made their input fail validation. In that case, sometimes nice, specific error messages are lacking in context. In addition to the errors, it’s often useful to include the input that made it fail.</p>

<p>You may be thinking “In that case, just include the context in the error messages”. That’s fine if you have one error message: less so if you have twenty, all repeating the same (potentially large) input object.</p>

<p>In addition, if you return a tuple of the input object and the errors, you can feed the output of one validation into another to compose them into a single, larger validator. If all you had was the list of errors, you no longer have an input object to apply validation to.</p>

<p>So that’s what a validation is, in the context of this library: a function which takes an input object, collates errors on it, and returns either the input object or a <code class="highlighter-rouge">FailedValidation&lt;T, E&gt;</code>, which contains the input object (of type <code class="highlighter-rouge">T</code>) and all the errors (each of type <code class="highlighter-rouge">E</code>). That gives us everything we are likely to need when validating.</p>

<h3 id="what-makes-sense-in-isolation-doesnt-always-in-context">What Makes Sense In Isolation, Doesn’t Always In Context.</h3>

<p>The only problem here is that we don’t always need all of that.</p>

<p>Oftentimes we want to run validations as part of a functional pipeline of steps: we might do some simple validations on our initial input object, then do some transformations, then validate the result of that, then persist it (persistence is <em>almost always</em> a potentially-failing-operation). For example, we may want to do something like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> 
        <span class="n">fizzbuzz</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> 
            <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="na">errors</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The only trouble here is: <code class="highlighter-rouge">FailedValidation&lt;T, E&gt;</code> is not a useful failure type in this sort of pipeline. If we validate, transform to another type, then validate again, we can’t have a consistent failure type, because the <code class="highlighter-rouge">T</code> parameter is different before and after the transformation. Here, we’d be happy with just the list of errors, which is one of the two ubiquitous failure types (the other being <code class="highlighter-rouge">Exception</code>).</p>

<p>There are various approaches here. One is to take the output of the validation and map failures to just the list of errors:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span>
        <span class="o">(</span><span class="n">fizzbuzz</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">treatFailuresAsList</span><span class="o">())</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">treatFailuresAsList</span><span class="o">()))))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> 
            <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>This works, but it’s not super approachable or discoverable.</p>

<p>We have a new level of nesting that’s appeared: we’re modifying the functions <em>within</em> a mapping, rather than adding to the top-level pipeline - but that’s needed because we need to unify the types before returning to the level of the pipeline. This adds another layer of complexity, which is the last thing we need.</p>

<p>It’s also bad for discoverability because the first time you come across this case, if you’re good, you’ll stare at the type errors for a bit, do some extraction of variables, and eventually work out why it’s not compiling. Working out how to solve it, though, requires enough experience to know that this is the trick you need in this situation. This is not friendly for newcomers.</p>

<p>So we started reconsidering whether or not we’d just be better off with a list of errors in the first place. In doing so, we came up with a nice idea.</p>

<h3 id="a-nice-idea">A Nice Idea</h3>

<p>What if our <code class="highlighter-rouge">FailedValidation&lt;T, E&gt;</code> <em>was</em> a <code class="highlighter-rouge">List&lt;E&gt;</code>? It contains a list, so surely we can present it as one? It’s even pretty simple to do using a cool pattern that takes advantage of default methods:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ForwardingList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">delegate</span><span class="o">();</span>

    <span class="k">default</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">delegate</span><span class="o">().</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>

    <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">delegate</span><span class="o">().</span><span class="na">isEmpty</span><span class="o">();</span> <span class="o">}</span>

    <span class="o">...</span> <span class="n">etc</span> <span class="k">for</span> <span class="n">the</span> <span class="n">other</span> <span class="mi">28</span><span class="o">(!)</span> <span class="n">methods</span> <span class="n">on</span> <span class="n">the</span> <span class="n">List</span> <span class="kd">interface</span> <span class="err">...</span>
<span class="err">}</span>
</code></pre>
</div>

<p>Just implement <code class="highlighter-rouge">ForwardingList</code> on your type, and implement the <code class="highlighter-rouge">delegate()</code> method which presents the object as a list, and you’re done.</p>

<p>Even implementing <code class="highlighter-rouge">ForwardingList</code> (or any other forwarding interface) isn’t hard. It’s a lot of code, sure, but you don’t need to write it manually: any good IDE and a little bit of regex-fu will get you there. There are lines of code in there which have never been viewed by human eyes.</p>

<p>So, now our <code class="highlighter-rouge">FailedValidation</code> is a <code class="highlighter-rouge">List</code>, we’re sorted, right?</p>

<p>Well, no. Even though a <code class="highlighter-rouge">FailedValidation</code> is a <code class="highlighter-rouge">List</code>, that doesn’t mean it is a <code class="highlighter-rouge">List</code>.</p>

<h3 id="a-brief-note-on-subtyping-variance-and-generics">A Brief Note On Subtyping, Variance and Generics</h3>

<p>Now, a <code class="highlighter-rouge">FailedValidation</code> is a <em>subtype</em> of <code class="highlighter-rouge">List</code>. That means we can assign a <code class="highlighter-rouge">FailedValidation</code> variable to a <code class="highlighter-rouge">List</code> variable. We can’t assign a <code class="highlighter-rouge">List</code> variable to a <code class="highlighter-rouge">FailedValidation</code>, though: all <code class="highlighter-rouge">FailedValidation</code>s are <code class="highlighter-rouge">List</code>s but not vice-versa.</p>

<p>But we’re not dealing with <code class="highlighter-rouge">FailedValidation</code>s in this case: we’re dealing with <code class="highlighter-rouge">Function</code>s and <code class="highlighter-rouge">Result</code>s over <code class="highlighter-rouge">FailedValidation</code>s, and in that case we need to understand the difference between covariance and contravariance. Let’s just look at functions, to start off with.</p>

<p>In principle, a sufficiently smart compiler would know that a <code class="highlighter-rouge">Function&lt;String, FailedValidation&gt;</code> is a subtype of <code class="highlighter-rouge">Function&lt;String, List&gt;</code>. Anywhere you need a function which returns a <code class="highlighter-rouge">List</code>, you can use a function which returns a <code class="highlighter-rouge">FailedValidation</code>, because the return values you get <em>are</em> <code class="highlighter-rouge">List</code>s. This is <em>co</em>variance: the subtyping rules of the type parameter are the same as they would be for a regular variable.</p>

<p>Similarly, a sufficiently smart compiler would know that a <code class="highlighter-rouge">Function&lt;List, String&gt;</code> is a subtype of <code class="highlighter-rouge">Function&lt;FailedValidation, String&gt;</code>. Anywhere you will pass a <code class="highlighter-rouge">FailedValidation</code> to a function will work if the function takes any <code class="highlighter-rouge">List</code>, as the <code class="highlighter-rouge">FailedValidation</code> <em>is</em> a list. The inverse is not true: a function which takes only a <code class="highlighter-rouge">FailedValidation</code> and, for example, looks at its input parameter, will <em>not</em> work if passed a <code class="highlighter-rouge">List</code>, so you can’t assign a <code class="highlighter-rouge">Function&lt;FailedValidation, String&gt;</code> to a <code class="highlighter-rouge">Function&lt;List, String&gt;</code>. This is <em>contra</em>variance: the subtyping rules of the type parameter in that position are inverted from the subtyping rules or a regular variable.</p>

<p>The trouble with Java is: it’s not sufficiently smart. We have to be specific about how we want variance to work. Just to make life even harder, we have to do it with ugly, shoe-horned syntax in order to avoid introducing new keywords in Java 5. To put the frustration cherry on the top of the iceberg, we can’t even make principled statements about types like <code class="highlighter-rouge">Function&lt;I, O&gt;</code> to make the input type contravariant and the return type covariant for us (declaration-site variance): we have to handle variance modifiers every time we <em>use</em> the type (use-site variance)…</p>

<p>Anyway.</p>

<h3 id="now-back-to-the-good-part">Now Back To The Good Part</h3>

<p>What we’d <em>like</em>, in an ideal world, is to have a situation where if we have a <code class="highlighter-rouge">Result&lt;T, List&lt;E&gt;&gt;</code>, then we can <code class="highlighter-rouge">flatMap</code> it over something which provides a <code class="highlighter-rouge">Result&lt;T, FailedValidation&lt;?, E&gt;&gt;</code> and we end up with a <code class="highlighter-rouge">Result&lt;T, List&lt;E&gt;&gt;</code>. We know this is safe, because all we can do with a failure type is read it, and a <code class="highlighter-rouge">FailedValidation</code> is readable as if it were a <code class="highlighter-rouge">List</code>.</p>

<p>Well, good news everybody! That’s entirely possible! Let’s start by looking at the original implementation of <code class="highlighter-rouge">flatMap</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="nl">Result:</span><span class="o">:</span><span class="n">failure</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Super simple: it takes in a function which takes a success and outputs a success or failure, and then returns a function which takes a <code class="highlighter-rouge">Result</code> and, if it’s a success, returns the output of running the input function on the success value, otherwise it returns the original failure.</p>

<p>Let’s see how we can make it do what we want with generalising to lists:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">IS</span><span class="o">,</span> <span class="n">OS</span><span class="o">,</span> <span class="n">OF</span><span class="o">,</span> <span class="n">IF</span> <span class="kd">extends</span> <span class="n">OF</span><span class="o">,</span> <span class="n">FF</span> <span class="kd">extends</span> <span class="n">OF</span><span class="o">&gt;</span> 
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">IS</span><span class="o">,</span> <span class="n">IF</span><span class="o">&gt;,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">OS</span><span class="o">,</span> <span class="n">OF</span><span class="o">&gt;&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">IS</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">OS</span><span class="o">,</span> <span class="n">FF</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="o">)</span> 
<span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span>
        <span class="n">success</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">success</span><span class="o">).</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="nl">Results:</span><span class="o">:</span><span class="n">upcast</span><span class="o">)),</span>
        <span class="n">fail</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="o">.&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">IF</span><span class="o">,</span> <span class="n">IF</span><span class="o">&gt;</span><span class="n">failure</span><span class="o">(</span><span class="n">fail</span><span class="o">).</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="nl">Results:</span><span class="o">:</span><span class="n">upcast</span><span class="o">)));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">upcast</span><span class="o">(</span><span class="n">T</span> <span class="n">fv</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">fv</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Oookay, that’s a little harder to grok. We have input and output success and failure types (IS, OS, IF, OF), and an additional failure type FF which comes from the mapping function. Furthermore, we have relationships between types: the output failure type is a supertype of both the input failure type and the mapping function’s failure type.</p>

<p>We also have a function <code class="highlighter-rouge">upcast</code> which appears to do exactly nothing, other than its return type is an arbitrary(?) supertype of the input value, and we’re mapping failures over that to… get the same value back, only this time the containing result has upcast it to an arbitrary(?) supertype?</p>

<p>Yeah, that’s what happens. Fortunately the compiler does some appropriate magic and finds the most appropriate (read: specific) type for the failure type, and converges on that. And with that implementation, our originating example compiles (and, of course, does exactly what we want):</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span>
        <span class="o">(</span><span class="n">fizzbuzz</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>So, now we can handle this particularly awkward case, by finding situations where the types might not align <em>exactly</em>, but we can go to the most specific common supertype and use that instead.</p>

<p>Isn’t that nice?</p>

<h3 id="the-danger-of-nice-things">The Danger of Nice Things</h3>

<p>Our problem here is that we’ve been looking at two types which are very similar, which are very closely related. We had two failure types which were more specific than we wanted, and by using some compiler magic, we converged on the type that we wanted.</p>

<p>It doesn’t always shake out like that. This change, as useful as it was in this particular narrow use case, breaks something important.</p>

<p>The problem with finding the most specific common supertype, as a default behaviour, is that <em>any two types have a common supertype</em>. A lot of the time it’s going to be <code class="highlighter-rouge">Object</code>.</p>

<p>One thing this change does is it makes this compile:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="nf">isHalfNPrime</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">divideExactlyByTwo</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">listFactors</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">divideExactlyByTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">number</span> <span class="o">+</span> <span class="s">" is odd: cannot divide exactly by two"</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">listFactors</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">primeFactors</span> <span class="o">=</span> <span class="n">IntStream</span>
        <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">number</span><span class="o">))</span>
        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">possibleDivisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">%</span> <span class="n">possibleDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">divisor</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="s">" is divisible by "</span> <span class="o">+</span> <span class="n">divisor</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">primeFactors</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
        <span class="o">?</span> <span class="n">Result</span><span class="o">.</span><span class="na">success</span><span class="o">(</span><span class="n">number</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">Result</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">primeFactors</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>And we started off by saying how having this fail to compile, due to incoherent failure types, was a desirable thing.</p>

<p>So let’s see if we can find a better way.</p>

<h3 id="can-we-have-our-cake-and-eat-it">Can We Have Our Cake And Eat It?</h3>

<p>What we really want to avoid here is accidentally over-generalising our failure type, whilst at the same time allowing safe generalisations. Is there any sensible way of distinguishing between them in a principled way? Well, let’s look at the possible cases in turn:</p>

<ol>
  <li>Incoming Failure Type Exactly Matches Existing Failure Type
    <ul>
      <li>We’re happy! This is how we wished the world always works.</li>
    </ul>
  </li>
  <li>Incoming Failure Type Is Subtype Of Existing Failure Type
    <ul>
      <li>In this case, we’re not generalising the failure type: we’re just allowing our overly-specific new failure provider to be consistent with the existing failure type. It seems reasonable to allow this to be upcast.</li>
    </ul>
  </li>
  <li>Incoming Failure Type Is Supertype Of Existing Failure Type
    <ul>
      <li>This is probably a result of using an overly-specific failure type earlier in the chain, so it’s probably fair to generalise the type to the incoming failure type. It seems reasonable to allow this to be upcast.</li>
    </ul>
  </li>
  <li>Incoming Failure Type Is Neither Subtype Nor Supertype Of Existing Failure Type
    <ul>
      <li>There are some cases where this is reasonable to upcast, but <em>all the cases where it isn’t</em> inhabit this zone. This is what we want to specifically disallow.</li>
    </ul>
  </li>
</ol>

<p>Okay. So, it’d be nice if we could allow our magic to work in cases 1, 2 and 3, but not 4. Our original, simple version of <code class="highlighter-rouge">flatMap</code> does 1 already. Now we know the tricks, it’s easy to write it so it does 2:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">FF</span> <span class="kd">extends</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;</span> 
    <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">FF</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="o">)</span> 
<span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span>
        <span class="n">success</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">success</span><span class="o">).</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="nl">Results:</span><span class="o">:</span><span class="n">upcast</span><span class="o">)),</span>
        <span class="nl">Result:</span><span class="o">:</span><span class="n">failure</span>
    <span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">upcast</span><span class="o">(</span><span class="n">T</span> <span class="n">fv</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">fv</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>And it’s easy to write it so it does 3:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">IF</span> <span class="kd">extends</span> <span class="n">F</span><span class="o">&gt;</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">IF</span><span class="o">&gt;,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> 
    <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="o">)</span> 
<span class="o">{</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">either</span><span class="o">(</span>
        <span class="n">f</span><span class="o">,</span>
        <span class="n">fail</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="o">.&lt;</span><span class="n">S1</span><span class="o">,</span> <span class="n">IF</span><span class="o">,</span> <span class="n">IF</span><span class="o">&gt;</span><span class="n">failure</span><span class="o">(</span><span class="n">fail</span><span class="o">).</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="nl">Results:</span><span class="o">:</span><span class="n">upcast</span><span class="o">)));</span>
<span class="o">}</span>


<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">upcast</span><span class="o">(</span><span class="n">T</span> <span class="n">fv</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">fv</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>But it’s not possible, as far as I can see, to write it so it does 2 and 3 at the same time, but <em>doesn’t</em> do 4. Well, I can’t see a way: it would be the height of hubris to say it’s not possible just because I can’t see a way of doing it. That’s never stopped me before, though.</p>

<p>We <em>could</em> have two methods, one which generalises towards the predecessor failure and one which generalises towards the incoming failure, but that feels like it requires too much prior knowledge to make use of it properly. We could have it do neither, and rely on the user to make types conform, but that feels like throwing the baby out with the bathwater.</p>

<p>So let’s assume we’re using one or the other. How do we deal with the unhandled type mismatch in each case?</p>

<h3 id="we-can-do-this-the-easy-way-or-the-hard-way-jk-lol-this-is-java">We Can Do This The Easy Way, Or The Hard Way. JK Lol, This Is Java</h3>

<p>We already have one way of transforming types: we map the failures. We had an example of this when we just had simple <code class="highlighter-rouge">FailedValidation</code> objects, and we decided we didn’t like it because it introduced a level of nesting. Well, that’s not necessarily true: we need to nest that failure transformation if our new failure type doesn’t match the existing failure type, but if we want to align our existing failure type with a more general new failure type, we can do that at the basic pipeline level:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> 
        <span class="n">fizzbuzz</span>
        <span class=pink><span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailures</span><span class="o">(</span><span class="n">treatFailuresAsList</span><span class="o">()))</span></span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
        <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> 
            <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="na">errors</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>As it happens, the pink function here is actually doing a transformation - taking the list out of the <code class="highlighter-rouge">FailedValidation</code> - but we could just as easily make it a type coercion:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span>
        <span class="o">(</span><span class="n">fizzbuzz</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
            <span class=pink><span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">WithTypes</span><span class="o">.&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="n">forFailures</span><span class="o">().</span><span class="na">convert</span><span class="o">())</span></span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Well, I say just as easily, but it requires a little bit of behind-the-scenesery:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Types</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">NF</span><span class="o">&gt;</span> <span class="n">FailureConverter</span><span class="o">&lt;</span><span class="n">NF</span><span class="o">&gt;</span> <span class="nf">forFailures</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">FailureConverter</span><span class="o">&lt;</span><span class="n">NF</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="n">NF</span><span class="o">&gt;</span> <span class="n">Attempt</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">NF</span><span class="o">&gt;</span> <span class="nf">convert</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">result</span> <span class="o">-&gt;</span> <span class="n">result</span><span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="nl">Types:</span><span class="o">:</span><span class="n">upcast</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">FailureConverter</span><span class="o">&lt;</span><span class="n">NF</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span> <span class="kd">extends</span> <span class="n">NF</span><span class="o">&gt;</span> <span class="n">Attempt</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="o">,</span> <span class="n">NF</span><span class="o">&gt;</span> <span class="nf">convert</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">upcast</span><span class="o">(</span><span class="n">T</span> <span class="n">fv</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fv</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>There are a couple of things that are a touch ugly here. It would be lovely if we could instead phrase our coercion like this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span> <span class="nf">isThisAnInterview</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">Validators</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"fizz"</span><span class="o">),</span>
        <span class="n">rejectIf</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"buzz"</span><span class="o">));</span>

    <span class="n">Validator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">under100</span> <span class="o">=</span> <span class="n">rejectIf</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" is too damn high"</span><span class="o">);</span>

    <span class="k">return</span> <span class="nf">with</span><span class="o">(</span><span class="n">m</span><span class="o">,</span>
        <span class="o">(</span><span class="n">fizzbuzz</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
            <span class=pink><span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">WithTypes</span><span class="o">.&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="n">forFailures</span><span class="o">())</span></span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">flatMap</span><span class="o">(</span><span class="n">under100</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"Great success! "</span> <span class="o">+</span> <span class="n">s</span><span class="o">))</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">mapFailure</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="s">"Big fails :( "</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">f</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">andFinally</span><span class="o">(</span><span class="n">collapse</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>And thus skip the call to <code class="highlighter-rouge">convert()</code>, but I can’t see a way of doing that, because <code class="highlighter-rouge">then()</code> expects an <code class="highlighter-rouge">Attempt</code> which has many types, and we want to only specify the type we care about: the target failure type. Doing our magic in the <code class="highlighter-rouge">convert</code> mechanism allows the other types to be inferred.</p>

<p>We could do it by making it an inferred generic call, where it does its magic on a parameter, such as a class - but while a class is fine when we have a non-generic failure type, we can’t represent a generic <code class="highlighter-rouge">List&lt;T&gt;</code> via a class parameter. That’s why it’s important we have a syntax which allows explicitly stating arbitrarily nested generics as the target failure type.</p>

<p>Given how warty Java can be, if that’s the most elegant I can make it, I’m not too upset. I think this is a pretty happy medium, on the whole.</p>

<h3 id="summing-up">Summing Up</h3>

<p>Sometimes we have a pipeline of <code class="highlighter-rouge">Result</code>s where the success or failure types aren’t the same, and we need to highlight that early because it’s evidence we’ve done something very wrong.</p>

<p>Sometimes we have a pipeline of <code class="highlighter-rouge">Result</code>s where the success or failure types aren’t exactly the same, but it’s reasonable to upcast one of them to the type of the other. It’s not possible to systematically do this in a bilateral way, but it’s better to do it for newly-incoming failures than existing failures for three reasons:</p>

<ol>
  <li>It’s easier to compose operations at the top level - the only level which should exist - this way.</li>
  <li>Upcasting incoming failures only widens types on one stage of failures, as opposed to arbitrarily many stages of failures that built the existing errors.</li>
  <li>Failure types are clearer, as once a failure type is established at one point in the pipeline, the only way it can be changed is by explicit type-changing calls (be they coercions or mappings).</li>
</ol>

<p>If I was working in Haskell, I wouldn’t even need to think about this stuff. Subtypes are hard. :(</p>

            </div>
            
            </div>
          </div>
          <div class="pagination">
              
                <a class="btn btn-default" href="/2017/08/reflections-on-equality" class="next">Newer Post</a>
              
              
                <a class="btn btn-default" href="/2017/02/failure-is-not-right" class="previous">Older Post</a>
              
          </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12 footer navbar-inverse navbar-fixed-bottom">
            <p class="copyright">&copy;2017 write once, read many. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="https://github.com/scotte/jekyll-clean">Scott Emmons</a>
            under
            <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a></p>
        </div>
    </div>
</div>






</body>
</html>

